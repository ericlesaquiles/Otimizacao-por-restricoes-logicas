\documentclass{article}

\input{../header.tex}
\usepackage[linguistics]{forest}
\usepackage{caption}

\captionsetup[figure]{name=Árvore}
\setlength{\belowcaptionskip}{1pt plus 1pt minus 1pt}
\setlength{\abovecaptionskip}{1pt plus 1pt minus 1pt}

\renewcommand\refname{Leituras Adicionais\\ \vspace{3mm} \normalsize{} \normalfont
  \\ A pesquisa e prática em programação lógica frequentemente é muito próxima à de linguagens funcionais e esse é o caso na área de transformações de programas. As transformações de \technical {folding/unfolding} foram primeiro adaptadas para a programação lógica por Tamaki e Sato \cite{tamaki}. Mais informações podem ser encontradas em \cite{ramakrishnan}. }


%
% TODO: revisar terminar esta seção!
%
%


\begin{document}

\section{Listas}

Antes de prosseguirmos em outros aspectos da programação lógica, ocasionalmente será util sabermos trabalhar com \textbf{listas}:

\begin{definition}
  Usaremos a seguinte definição formal de lista\marginpar{\textbf{Lista}}:
  \begin{itemize}
    \item {\tt .()} (o ``funtor .'') é uma lista\footnote{Na verdade, isso não é estritamente padrão e implementações diferentes podem usar funtores diferentes. Essa é outra razão para não usarmos essa definição na prática, mas sim a convenção seguinte. Apesar disso, é importante se lembrar que a lista não é, estritamente falando, diferente de um funtor.} (o que chamamos ``lista vazia'', é o mesmo que ``[]'' das seguintes convenções);
    \item {\tt .(A, B)} é uma lista se B é uma lista
  \end{itemize}
  Como é chato ficar escrevendo coisas como {\tt.(A, .(B, []))} usaremos as seguinte convenções:
  \begin{itemize}
    \item {\tt [A,B]} é o mesmo que {\tt .(A, .(B, .()))};
    \item {\tt [A]} é o mesmo que {\tt .(A, .())} (o funtor . é de aridade 2, a não ser quando não recebe argumentos);
    \item {\tt [A, B, C, ...]} é o mesmo que {\tt .(A, .(B, .(C, ...)))};
    \item {\tt [A|B]} indica que A é o primeiro elemento da lista (também chamado de \definicao{cabeça da lista}) e B é o resto da lista, também chamado de \definicao{corpo da lista} .
  \end{itemize}
\end{definition}

Dado isso, podemos escrever um programa para adicionar um elemento na lista como o seguinte:

\lstinputlisting[caption=Append]{../Exemplos/Cap2/prog2_append.pl}\label{lst:append}

Esse é um programa clássico e, por isso, escolhemos manter seu nome clássico, que, daqui para frente será usado sem itálico. Os dois elementos iniciais de append são listas e o final é o resultado de se ``juntar as duas listas'': cada elemento da primeira lista está, ordenadamente, antes da cada elemento da segunda. Para exercitar, pense em qual seria o resultado do goal {\tt append([cafe, queijo], [goiabada], L)?}.

Para uma melhor compreensão, será instrutivo analisarmos o seguinte programa:
\\
\\

\lstinputlisting[caption=Length]{../Exemplos/Cap3/prog2_length.pl}
\label{lst:length}

Mas antes, precisamos entender o que significa {\tt N is M + 1.}. Esse \textbf{is}\marginpar{\textbf{is}} é o operador de atribuição aritmético e ele não funciona como os demais predicados: para algo como {\tt A is B}, se B for uma constante numérica e A é uma variável, o comportamento é o esperado (A assume o valor de B); se não, ocorre erro. Disso segue que is/2 não é simétrico: por exemplo, {\tt A is 5} resulta em A = 5, mas {\tt 5 is A.},
onde A é uma variável, resulta em erro. Ademais, quando algum
operador aritmético\footnote{Operadores aritméticos que temos à disposição são: $+/2, -/2, */2, //2, \wedge/2, -/1, abs/1, sin/1, cos/1, max/2, sqrt/1, <</1, \gg/1$. O funcionamento de muitos deles é claro pelo símbolo, o dos demais será explicado na medida que forem usados.} \textit{op} é usado com is/2, o operador realiza a operação esperada: {\tt A is 2 + 3} e {\tt A is 10 - 8} resultam em A = 5, por exemplo. Vale notar que esse comportamento é diferente do =/2, por exemplo: o seguinte
programa pode não ter o resultado intuitivamente esperado:
% TODO arrumar << >>

\lstinputlisting[caption=Length]{../Exemplos/Cap3/prog3_length1.pl}

\noindent Intuitivamente, esperaríamos que o \var{N} fosse unificado, por um processo recursivo, com o número correspondente ao tamanho da lista. Isso não ocorre, porque =/2 tem um efeito puramente simbólico e não realiza operações aritméticas: o que teríamos em \var{N} seria algo como uma \textit{string} de símbolos \str{1+(1+(1+0))}, ao invés da avaliação dessa \foreign{string}, ou seja, 3.


Uma característica importante da lista, que lhe dá a flexibilidade necessária para poder representar muitos tipos de dados diferentes
é que ela é ``fechada sob a relação de instanciação'', isto é, não existe problema em fazer uma lista de listas. Assim, uma lista
perfeitamente válida é \codigo{[[[a,b],c],[]]}. Algumas vezes, entretanto, será útil assumirmos que uma lista \var{L} só contenha ``não-listas'' como elementos. Para tanto, podemos fazer uso do funtor flatten/1, que pode ser implementado como se segue:

\lstinputlisting[caption=Flatten]{../Exemplos/Cap3/prog3_flatten.pl}

\noindent O atomic/1 usado é avaliado como sucesso se seu argumento for uma constante (símbolo ou número).

 Voltando aos operadores, além do is/2, temos \textbf{operadores de comparação} (também chamados de operadores relacionais), que funcionam de maneira semelhante e também possibilitam o uso de operadores aritméticos à direita do símbolo, na maneira usual. Eles serão de alguma importância:


\begin{itemize}
  \item $=:=$/2, de igualdade;
  \item $=/=/2$, de desigualdade;
  \item $>/2  $, de ``maior que'';
  \item $>=/2$, de ``maior ou igual que'';
  \item $</2 $, de ``menor que'';
  \item $=</2$, de ``menor ou igual que'';
\end{itemize}


Voltando ao código \ref{lst:length}.
O goal {\tt length(Xs, N)?}, onde Xs é uma lista e N uma variável, resulta em N tomando o valor da quantidade de elementos de Xs (o seu ``tamanho'').  Mas, o goal {\tt length(Xs, N)?}, onde N é um número natural positivo e Xs uma variável resulta em erro ao chegar no trecho {\tt N is K + 1}, uma vez que, como dito anteriormente, {\tt N is K}, onde N é um número, resulta em erro.

Para o seguinte programa, esse já não é o caso.

\lstinputlisting[caption=Length]{../Exemplos/Cap3/prog3_length2.pl}

O goal \codigo{length(Xs, N)?}, para esse programa, resulta em erro se N não for um número. Entretanto, se for um natural positivo, \codigo{length(Xs, N)?} resulta em sucesso e Xs se torna uma lista de N elementos. Se Xs for uma lista e N um natural positivo, \codigo{length(Xs, N)?} resulta em falha se Xs tem uma quantidade de elementos diferente de N e sucesso se Xs tem uma quantidade de elementos igual a N.

Nota-se que, apesar dessa diferença procedural, a leitura declarativa do programa é essencialmente a mesma. A diferença decorre da maneira como os operadores aritméticos funcionam em Prolog e leva a outras situações parecidas, o que eventualmente se tornará um incoveniente grande demais. Veremos como lidar com esse tipo de incoveniente de maneiras diferentes no capítulo de inspeção de estruturas %COMMENT: colocar "(Capítulo x)".
e, depois, no de restrições lógicas. %COMMENT: colocar "(Capítulo y)". Isso facilita para quem quiser procurar o capitulo.

Agora, voltando rapidamente a um assunto discutido no capítulo passado, temos a definição de \textbf{lista completa}\marginpar{\textbf{lista completa}}:

\begin{definition} Uma lista L é completa se toda instância L$\iota$ satisfaz a definição de lista dada. Se existem instâncias que não a satisfazem, ela é dita incompleta.
\end{definition}

Por exemplo, a lista {\tt[a,b,c]} (menos popularmente conhecida como \codigo{.(a,.(b,} \codigo{.(c,[])))} é completa: a \codigo{[a,b|Xs]} (menos popularmente conhecida como \codigo{.(a,} \codigo{.(b,Xs))}), não. Isso porque \var{Xs} não tem, a princípio, obrigação de ser uma lista.

\subsection{Listas de diferença}

Estruturas de dados incompletas, no geral, podem ser bem importantes e úteis. Um exemplo interessante são as \definicao{listas de diferença}, uma estrutura de dados que pode simplificar e aumentar a eficiência de programas que lidam com listas.

Listas de diferença tem esse nome porque são criadas como a diferença de duas listas. Por exemplo, dizemos que  a diferença entre as listas
\codigo{[a,b,c]} e \codigo{[c]} é a lista \codigo{[a,b]}. A diferença entre duas listas incompletas \codigo{[a,b|Xs]} e \codigo{Xs} é equivalente à lista \codigo{[a,b]} e, mais no geral, a diferença entre duas listas incompletas \codigo{[$x_0$, ...,$x_i$|Xs]} e \codigo{Xs} é equivalente a \codigo{[$x_0$, ...,$x_i$]}.
A diferença entra as listas \var{Ys} e \var{Xs}, onde \codigo{Ys = [Zs|Xs]}, é denotada \codigo{Ys$\setminus$Xs}, onde \var{Ys} é dita a \enphasis{cabeça} e \enphasis{Xs} a cauda. Na prática,
poderíamos definir um funtor tal como lista\_diff/2, o que seria potencialmente mais eficiente, mas a notação anterior será
mais conveniente pelo momento. Se eficiência for uma preocupação, termos como \codigo{Ys$\setminus$Xs} poderiam ser substituídos automaticamente por outro funtor apropriado.

É importante notar que qualquer lista \var{L} pode ser trivialmente representada na forma de lista de diferença como \codigo{L$\setminus$[]}. Fazer a concatenação de uma lista de diferença \codigo{Ys$\setminus$Xs} com uma \codigo{Zs$\setminus$Ws}
só é possível quando \var{Xs} seja unificavel com \var{Zs}, sendo, nessa ocasião, ditas \definicao{listas compatíveis}  e, nesse caso, resulta na lista de diferença \codigo{Zs$\setminus$Xs}. Esse fato é capturado no seguinte código:

\lstinputlisting[caption=Append DL]{../Exemplos/Cap3/prog5_concatenate_diff.pl}\label{lst:append_dl}

Perceba que, enquanto no código \ref{lst:append} a concatenação realiza uma quantidade de operações linear no tamanho da lista,
no código \ref{lst:append_dl} a concatenação é realizada em uma quantidade constante de operações.

Outro exemplo de programa que poderia ser melhorado com o uso de listas de diferença é o flatten/2. Se queremos realizar o \technical{flatten} de uma lista Xs e temos um flatten\_dl/2 que realiza o flatten em uma lista diferença, sabemos que \codigo{flatten(Xs,Ys)} é o mesmo que \codigo{flatten\_dl(Xs$\setminus$[], Ys$\setminus$[])}. Um flatten\_dl/2 pode ser como o seguinte:

\lstinputlisting[caption=Flatten DL]{../Exemplos/Cap3/prog_flatten_dl1.pl}\label{lst:flatten_dl}

Perceba agora que o passo em que usamos append\_dl/2, no código \ref{lst:flatten_dl}, pode ser feito de maneira implícita, resultando no seguinte

\lstinputlisting[caption=Flatten DL o retorno]{../Exemplos/Cap3/prog_flatten_dl2.pl}\label{lst:flatten_dl2}

\noindent que parece melhor do que nosso flatten/2 original. Essa mudança poderia ser obtida automaticamente com uma aplicação de um \technical{unfolding}.
\technical{Unfolding} é um tipo de ``transformação programática'' que consiste, em termos gerais, na substituição de um goal por
sua definição e é o contrário de \technical{folding}, que consiste na substituição do corpo de uma cláusula por sua cabeça. Essas
transformações são úteis na otimização de código e para outras coisas, que fogem do nosso escopo atual.

Vistos os exemplos de listas de diferença dados, é justo dizer que a ideia de estruturas de diferença parecem boas e nos perguntar se ela não é generalizavel
para tipos de dados diferentes de listas. Para tanto, precisamos desenvolver uma representação um pouco melhor de o que a lista é
e como ela funciona. Uma lista, como a definimos acima, é uma forma de representar uma árvore. Por exemplo, a lista \codigo{[a,b,c]} se parece com:

\begin{figure}[h]

  \caption{Lista simples}\label{fig:simp_list}

  \begin{center}
    \begin{forest}
      for tree={
        parent anchor=south,
        child anchor=north,
      }
      [$\bullet$
        [a]
        [$\bullet$
          [b]
          [$\bullet$
            [c]
            [ {[ ]}  ]
          ]
          ]
      ]
    \end{forest}
  \end{center}

\end{figure}

\noindent onde o $\bullet$ representa o funtor ./2 da lista. Na verdade, funtores em geral são árvores, não só os de lista, mas
funtores de lista tem essa ``cara especial''. Uma lista como \codigo{[[a,b],c]} seria como:

  \begin{figure}[h]

    \caption[tree]{Lista aninhada}\label{fig:nest_list}

    \begin{center}
      \begin{forest}
        for tree={
          parent anchor=south,
          child anchor=north,
        }
        [$\bullet$
          [$\bullet$
            [a]
            [$\bullet$
              [b]
              [ {[ ]} ]
            ]
          ]
          [$\bullet$
              [c]
              [{[ ]}]
          ]
        ]
      \end{forest}
  \end{center}

  \end{figure}

O que flatten/2 faz é uma transformação em árvores como essa, transformando uma lista aninhada como a \ref{fig:nest_list} em uma
simples, como a \ref{fig:simp_list}. No caso, o resultado de flatten na lista \ref{fig:nest_list} (que é uma árvore) seria a lista
\ref{fig:simp_list}.

Agora, para vermos como uma estrutura de diferença pode ser útil em outras ocasiões, considere o seguinte exemplo. Em Prolog, a
operação de soma é associativo a esquerda, o que significa que a operação \codigo{1 + 1 + 1 + 1} é tomada como \codigo{(((1 + 1) + 1) + 1)}.
Por razões técnicas, podemos querer que ela seja normalizada como associativa à direita. Ou seja, se temos algo como
\codigo{(1 + 2) + (3 + 4)}, dado pela árvore


  \begin{figure}[h]

    \caption[tree]{Soma}\label{fig:sum}
    \begin{center}
      \begin{forest}
        for tree={
          parent anchor=south,
          child anchor=north,
        }
        [+
          [+
            [1]
            [2]
          ]
          [+
              [3]
              [4]
          ]
        ]
      \end{forest}
  \end{center}

  \end{figure}


\noindent queremos que isso se torne \codigo{ (1 + (2 +  (3 + 4)))}, dado pela árvore \ref{fig:sum_norm}.

  \begin{figure}[h]

    \caption[tree]{Soma normalizada}\label{fig:sum_norm}
    \begin{center}
      \begin{forest}
        for tree={
          parent anchor=south,
          child anchor=north,
        }
        [+
          [1]
          [+
            [2]
            [+
              [3]
              [4]
            ]
          ]
        ]
      \end{forest}
  \end{center}

  \end{figure}


O que precisamos é de uma forma de normalizar
essa operação. Para tanto, precisamos de um novo funtor (já que o ``+'' já está em uso). Definiremos o funtor ++/2 como um operador infixo, da seguinte forma:

\codigo{:- op(500, xfy, ++).}

\noindent Resumidamente, essa linha nos diz que o funtor ++/2 é um operador binário (podemos usá-lo na forma \codigo{A ++ B}), de prioridade
500 (quando maior o número, menor a prioridade de avaliação, sendo a menor prioridade possível dada por 1200) e associativo à direita (yfx seria associativo à esquerda e xfx seria não-associativo).

Com esse funtor em mãos, definimos a ``soma de diferença'' de maneira análoga à lista de diferença, isto é, como \codigo{S1++S2},
onde \var{S1} e \var{S2} são somas normalizadas incompletas. Nesse contexto, o número 0 faz o papel da lista vazia e
\codigo{S1++0} é equivalente a \var{S1}. Assim, podemos definir o seguinte código:

\lstinputlisting[caption=Normalize]{../Exemplos/Cap3/progn_normalized_sum.pl}\label{lst:norm}

\noindent O goal \codigo{Normalize(Exp, Norm)} tem sucesso se \var{Norm} é a versão normalizada da expressão \var{Exp}.
Perceba a semelhança entre esse normalizador e o flatten/2: a transformação feita na árvore é essencialmente a mesma. De uma
expressão \codigo{A+B}, é como se tivessemos normalizado \var{A}, normalizado \var{B} e, então, concatenado o
resultado (como seria uma operação de concatenação de ``somas de diferença''?).

Fica como exercício a seguinte questão: qual seria o comportamento esperado nas operações usuais de listas de diferença
\codigo{Xs$\setminus$Zs} quando $Xs \subset Zs$
(isto é, quando os elementos de \var{Xs} pertencem a \var{Zs} mas alguns de \var{Zs} podem não pertencer a \var{Xs})?


    A pesquisa e prática em programação lógica frequentemente é muito próxima à de linguagens funcionais e esse é o caso
    na área de transformações de programas. As transformações de \technical {folding/unfolding} foram primeiro adaptadas para
    a programação lógica por Tamaki e Sato \cite{tamaki}. Mais informações podem ser encontradas em \cite{ramakrishnan}.

  \begin{thebibliography}{1}


    \bibitem{tamaki}
    Tamaki, H. and Sato, T.,
    ``Unfold/Fold Transformations of Logic Programs'',
    Proc. Second International Conference on Logic Programming,
    pp. 127-138,
    Uppsala, Sweden, 1984.


    \bibitem{ramakrishnan}
    Roychoudhury, A. and Kumar Narayan K. and Ramakrishnan C.R. and Ramakrishnan I.V.,
    ``Beyond Tamaki-Sato Style Unfold/Fold Transformations for Normal Logic Programs'',
    International Journal of Foundations of Computer Science,
    World Scientific Publishing Company


  \end{thebibliography}


\end{document}
