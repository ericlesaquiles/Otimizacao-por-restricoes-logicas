\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{placeins}

\usepackage{listings}
\lstset{language=Prolog}
\renewcommand{\lstlistingname}{Código}

\usepackage{amsthm}

%\theoremstyle{definition}
\newtheorem{definition}{Definição}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\theoremstyle{theorem}
\newtheorem{theorem}{Teorema}[section]

\setlength{\parskip}{.5em}




%
% TODO: revisar esta seção!
%

\begin{document}
\section{Predicados de Inspeção de Estrutura}

Predicados de inspeção de estrutura nos passam informações sobre um termo específico. Por exemplo, será um termo atômico, numérico, constante, variável? Ou será um funtor composto? Se for, qual será seu funtor principal, qual sua aridade e quais seus argumentos? É esse tipo de questão que os predicados de inspeção de estrutura respondem.

\subsection{Predicados de tipos}

Alguns dos, assim chamados, predicados de tipo são:

\begin{itemize}
  \item integer/1;
  \item real/1;
  \item atom/1;
  \item compound/1;
\end{itemize}

Cada um deles pode ser interpretado como uma lista infinita de átomos. Por exemplo, integer/1 pode ser interpretado como: {\tt integer(0). integer(1). integer(2). integer(3), ...}.

A partir desses predicados podemos criar outros. Por exemplo, podemos fazer {\tt numero(X) :- integer(X);real(X).}, ou {\tt constante(X) :- numero(X); atom(X).}.

\subsection{Acesso de termos compostos}

Queremos ser capaz, além de lidar com tipos, lidar com funtores. Para acessar o funtor principal, temos o predicado functor/3. {\tt functor(Termo, F, Aridade)?} tem sucesso se o funtor principal de Termo tem aridade Aridade e nome F. Assim, por exemplo, {\tt functor(f($x_1$, ..., $X_n$), f, n)} tem sucesso, já que o funtor principal é f/n.

Pode-se usar esse predicado para, entre outras coisas, decomposição e criação de termos:
\begin{enumerate}
  \item{\tt functor(tio(a,b), X, Y)?} tem como solução \{X = tio, Y = 2\};
  \item{\tt functor(F, tio, 2)} tem como solução \{F = tio\}.
\end{enumerate}

Note que, no Exemplo 2, se o goal fosse {\tt functor(F, tio, N)?}, teríamos erro, já que o interpretador não consegue adivinhar a aridade de um funtor a partir do nome. Analogamente, %COMMENT: em todos os casos em que a palavra original era proparoxitona - e, por isso, acentuada - quando escreve o adverbio - com o "mente" no final - voce manteve o acento, mas esse acento desaparece.
{\tt functor(F, tio(a, b), N)?} resultaria em erro, já que {\tt functor} espera um átomo como segundo argumento, não um funtor composto. Mas, {\tt functor(tio, X, N)?} teria sucesso, com \{X = tio, N = 0\} (átomos são considerados funtores de aridade 0).

Similar, a functor/3 é o arg/3: {\tt arg(N, F($X_1$, ..., $X_n$), Q)?} tem sucesso se o N-ésimo argumento de F é o Q. Assim como functor, arg/3 é comumente usado para decomposição e criação de termos:
\begin{itemize}
  \item Para decompor um termo, arg/3 acha um argumento particular de um termo composto;
  \item Para criar um termo, ele instancia um argumento variável de um termo.
\end{itemize}

Por exemplo, {\tt arg(1, tio(a,b), X)?} tem sucesso com \{X = a\}, enquanto que {\tt arg(1, tio(X,b), a)?} tem sucesso com \{X = a\}.

Exemplos um pouco mais interessantes são os seguintes:

\lstinputlisting[caption= Sub Termo]{../Exemplos/Cap6/prog1_subtermo.pl}

\lstinputlisting[caption= Substituto]{../Exemplos/Cap6/prog2_substitui.pl}

Outro predicado de inspeção de estrutura é o, assim chamado, \textit{univ}, escrito como {\tt =../2}\footnote{Predicados para acesso e construção de termos têm origem na família Prolog de Edinburgo (que tem se tornado o padrão de fato) e alguns dos nomes usados vêm de lá. A forma “=..” para \textit{univ} vem do Prolog-10, onde era usado “,..” no lugar de “|” em listas ({\tt[a, b,.. Xs]} no lugar de {\tt [a, b|Xs]}).}. Um exemplo de seu uso é {\tt Termo =.. [f,a,b]?}, com o resultado \{Termo = f(a, b)\}.
O \textit{univ} pode ser usado de essencialmente duas formas diferentes:
\begin{enumerate}
  \item Com um funtor ao lado esquerdo e uma váriavel no direito: a variável é unificada com {\tt [f|v]}, onde f é o funtor principal e V a lista de seus argumentos;
  \item Com uma variável ao lado esquerdo e uma lista no direito: se a lista é {\tt [a, $b_1$, ..., $b_n$]}, a variável é unificada com {\tt a($b_1$, ..., $b_n$)}.
\end{enumerate}

O seguinte programa mostra um exemplo da utilidade de \textit{univ}:

\lstinputlisting[caption= Map]{../Exemplos/Cap6/prog3_apply.pl}

\subsection{Predicados de Meta-Programação}

O predicado de meta-programação básico é o var/1: {\tt var{T}?} tem sucesso se T é uma variável não instanciada, e falha caso contrário. Sua irmã, nonvar/1, funciona de maneira análoga. Por exemplo, {\tt var(a)?} e {\tt var([X|Xs])?} falham, enquanto que {\tt var(X)?} tem sucesso, se X é uma variável não instanciada.

Esse tipo de predicado é chamado meta-predicado: eles são ``predicados sobre predicados''. Como tais, podem prover grande flexibilidade a um programa lógico.


\subsection{Operações Aritméticas}

%COMMENT: uma parte do que esta aqui tambem ja foi explicada no capitulo 4. Nao sei se nao compensa inverter a ordem destes capitulos.

Antes de continuarmos, será útil introduzirmos operações aritméticas. Primeiro, é importante notar que a atribuição de uma operação aritmética, no Prolog, funciona de maneira diferente da unificação. Ela é do tipo {\tt X is A Op B.}, onde {\tt Op} é uma operação com valores aritméticos (que resulta em um valor aritmético) do tipo a que estamos acostumados: 1 + 2, 3 * 8, (1 - 5)/4 + 33475, etc, e A e B são valores.
É importante notar que operações aritméticas só podem ser feitas com números: A Op B, onde Op é  uma operação aritmética, resulta em erro se A ou B for uma variável ou uma constante não numérica. Vale notar que is/2 não é simétrico: {\tt 5 + 4 is A} resulta em erro.

Assim, vemos que o operador de ou exclusivo (o xor), por exemplo, não age da maneira como estamos acostumados: gostaríamos que {\tt 1 is A xor 0} seja equivalente a {\tt A is 1}.
Veremos mais tarde outras formas de contornarmos isso, mas, por ora, podemos lidar com isso por meio de predicados de meta-programação:
\\

\lstinputlisting[caption=Ou Exclusivo]{../Exemplos/Cap6/prog3_xor.pl}


\end{document}
