\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{placeins}

\usepackage{amsthm}
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\usepackage{listings}
\lstset{language=Prolog}
\renewcommand{\lstlistingname}{Código}

\renewcommand\refname{Leituras adicionais}

\newtheorem{definition}{Definição}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\usepackage[ruled,vlined,linesnumbered]{algorithm2e}

\setlength{\parskip}{.5em}

\usepackage{epigraph}
\setlength\epigraphwidth{0.9\linewidth}
\setlength\epigraphrule{0pt}



%
% TODO: revisar terminar esta seção!
%
%


\begin{document}

\section{Dando nome aos bois}

\epigraph{\textit{Foi a influência da filosofia grega que fez da matemática uma ciência. De fato, os primeiros matemáticos gregos estão entre os primeiros filósofos, como é o caso de Tales e Pitágoras. A noção de que um fato matemático pode ser demonstrado é fruto da interação entre matemática e filosofia. Afinal, uma demonstração é essencialmente um argumento para esclarecer como um certo fato é consequência de algo que já conhecemos. E se há alguma coisa que os filósofos gregos gostavam de
    fazer era argumentar.}}{S. C. Coutinho - Números Inteiros e Criptografia RSA}


Neste capítulo serão explicadas algumas noções mais ou menos simples e definidos alguns conceitos e convenções de que faremos uso posteriormente. Alguns dos termos usados aqui também são usados em outros contextos, mas com significado diferente. Por isso é importante tê-los claramente definidos.

É uma quantidade relativamente grande de definições que a leitora poderia, possivelmente, reconhecer de capítulos posteriores, mas estão postas aqui para referência. Dependendo de seu estilo, talvez considere mais interessante começar do Capítulo 1: continue por sua conta e risco. %TODO No futuro, colocar uma referencia para o label do capitulo 1, em vez de explicitar o 1.

Programação lógica surgiu da constatação de que programas são formados por uma parte lógica e uma parte procedural (uma parte que diz ``o que fazer'' e outra que diz ``como fazer''). Dada essa constatação, uma pergunta natural é ``Dá para separar a parte lógica da procedural, de modo que quem programa tenha que se preocupar somente com a lógica do programa?''. Da tentativa de responder a essa pergunta, nasceu o Prolog e a teoria de programação lógica. O Prolog não
feito com a intenção de ser uma resposta final, mas uma tentativa de resposta, a partir da qual poderiam ser feitos
melhoramentos. Apesar disso, por vários motivos (que serão notados ao longo do texto), vários mecanismos não puramente lógicos (isto é, não previstos pela \textit{teoria de programação lógica}, que veremos mais adiante) foram notados como úteis e permaneceram na linguagem contribuindo para que Prolog também tenha um sabor procedural, apesar da aparência enganadora. Se você se pergunta qual a resposta àquela pergunta inicial, é: não completamente.

Para desenvolver mais essa ideia, precisaremos de uma quantidade relativamente grande de novos conceitos e definições. Assim, existem duas rotas possíveis para a leitura: continuar por aqui e conhecer algumas das definições antes de usá-las, ou seguir pelo próximo capítulo e voltar aqui na medida do necessário, usando o capítulo atual como uma referência.


Antes de mais nada, vale lembrar que (diferentemente do que algumas pessoas podem pensar),
existe uma diferença entre programação lógica e Prolog: Prolog é uma implementação (e uma imperfeita) de programação lógica.
Uma entre várias outras. Aliás, esse é um dos motivos de ser importante estudar e perceber a programação lógica como algo separado (você pode querer aplicá-la em alguma outra linguagem). Outro motivo é a abstração a mais que permite desenvolver teorias com maior facilidade e liberdade. Apesar
disso, as notações que usaremos para Prolog e para programação lógica são frequentemente muito parecidas e não parece muito interessante explicar o que é essencialmente a mesma coisa duas vezes (já que usaremos a linguagem Prolog em diversas situações). No lugar disso, adotaremos a seguinte convenção.

As definições apresentadas serão as usadas no Prolog; quando houver diferenças relevantes entre as definições usadas em Prolog, em Programação lógica, ou entre outra teoria/linguagem utilizada, essa diferença será explicitada (isto é, quando não for dito o contrário, as definições e convenções de linguagem são assumidas como as mesmas).


  \theoremstyle{definition}
  \begin{definition} \textbf{Átomo}\marginpar{\textbf{Átomo}} é algo que seja:
    \begin{itemize}
      \item Uma sequência de caracteres entre aspas simples (\textit{`Qualquer coisa assim'});
      \item Ou uma sequência de caracteres alfabéticos, numéricos e \textit{underscore} (`\_') começando com um caractere alfabético minúsculo;
      \item Ou uma sequência contínua de caracteres dos símbolos: $+$, $-$, $*$, $/$, $\backslash$, \^{}, $>$, $<$, $=$, ', :, ., ?, @, \#, \$, \&. (e.g. ***+***+@);
      \item Ou algum dos seguintes átomos especiais: [,], \{,\}, ;, !.
    \end{itemize}
  \end{definition}


  \theoremstyle{definition}
  \begin{definition} Um \textbf{funtor}\marginpar{\textbf{Funtor}}
    \footnote{ O termo \textit{funtor} foi introduzido por Rudolf Carnap, filósofo alemão que participou do círculo de Viena, em seu \textit{Logische Syntax der Sprache}\cite{carnap} e indica uma \textit{palavra função}, que contribui primariamente com a sintaxe de uma sentença (em contraste com \textit{palavras conteúdo}, que contribuem primariamente com o significado): resumidamente, em sua concepção original, funtores expressam a estrutura relacional que palavras tem umas com as outras. O termo atualmente também é usado em outras áreas (além de em linguística e programação lógica), como em \textit{Teoria de Categoria}, com   significado semelhante (é claro, levando em conta o contexto).  }
    é um átomo seguido de $n$ argumentos fechados por parênteses e separados por vírgula:
    \[
      p(a_1, ..., a_n)
    \]
\noindent em que $p$ é um átomo e $a_1$ a $a_n$ são quaisquer termos. Quando $n = 0$, não são colocados parênteses e o funtor é apenas um átomo. Quando $n > 0$, o funtor é chamado \textbf{termo composto}\marginpar{\textbf{Termo composto}} e $p$ é chamado \textbf{funtor principal}\marginpar{\textbf{Funtor principal}}. Essa definição faz sentido porque cada um dos argumentos pode, por sua vez, ser um outro funtor.
  Não confunda funtor com função: sua única semelhança é na forma de se escrever.
  \end{definition}
Vale notar que os funtores são diferenciados por nome e aridade (quantidade de parâmetros). Assim, os funtores a seguir são distintos:
    \[
      f(a_1, a_2)
    \]
    \[
      f(a_1)
    \]

    Um funtor de aridade \textit{n} e nome \textit{p} será denotado \textit{p/n}.



  \theoremstyle{definition}
  \begin{definition} Um termo\marginpar{\textbf{Termo}} é um funtor (composto ou não), uma variável (o que são variáveis e como funcionam será visto adiante), ou um número (em especial, lidaremos com números inteiros e reais).
  \end{definition}

  Quando um termo for um átomo ou um número, diremos que ele é \textbf{atômico}\marginpar{\textbf{Atômico}}.

Quando um termo não contiver uma variável, diremos que ele é um \textbf{termo base}\marginpar{\textbf{Termo base}}.
Termos base serão um componente importante no desenvolvimento da teoria de programação lógica.

Com base nessas definições, podemos definir os blocos de construção da programação lógica, o que chamaremos de \textbf{cláusulas}\marginpar{\textbf{Cláusulas}}:
\begin{itemize}
  \item Fatos e
  \item Regras
\end{itemize}

Intuitivamente, fatos e regras são como axiomas matemáticos: a partir deles é possível fazer deduções.

Dos dois, fatos\marginpar{\textbf{Fatos}} são mais simples. Eles são escritos como  ${\tt p(a_1, ..., a_n).}$\footnote{Trechos escritos {\tt com esta fonte} no meio do texto devem ser entendidos como trechos de código.},  ou, mais resumidamente, {\tt p.}, isto é, um funtor e seus argumentos, seguido de um ponto final ``.''. Fatos podem ser lidos e entendidos como ``${\tt p(a_1, ..., a_n)}$ é verdade''(ou, ``é um fato'').

Regras\marginpar{\textbf{Regras}} são escritas como ${\tt p :- b_1, ..., b_n.}$, onde $p$ denota um funtor e $b_1$ a $b_n$ são termos quaisquer. Regras podem ser lidas e entendidas como {\tt p é verdade se $b_1$ a $b_n$ forem} (se ajudar, você pode ler o ``:-'' como uma seta de implica, $\leftarrow$, estilizada). É conveniente dar nomes diferentes para a parte de uma regra que vem à esquerda do ``:-'' da que vem à direita dele: o que vem à esquerda de ``:-'' (o ``p'' do nosso exemplo) será chamado \textit{cabeça} da cláusula e, o que vem à direita, \textit{corpo} da cláusula. Assim, a
\textit{cabeça} é verificada como verdadeira se o \textit{corpo} o for (mas não o contrário).

Um programa lógico consiste em um conjunto de cláusulas. Um exemplo é o seguinte:\\

\lstinputlisting[caption=Café]{../Exemplos/Cap0/prog1_cafe.pl}

Note que os nomes usados para os funtores são arbitrários. O seguinte programa tem essencialmente o mesmo significado\footnote{ Aqui, ``Essencialmente o mesmo'' significa ``o mesmo'', se não levarmos em conta os significados usuais dos nomes usados (em geral, levamos isso em conta).}:\\

\lstinputlisting[caption=Queijo]{../Exemplos/Cap0/prog2_queijo.pl}

A maneira primária de se utilizar um programa lógico é por meio de buscas, às vezes também chamadas objetivos ou de \textbf{\textit{goals}}\marginpar{\textbf{Goal}} (daqui para frente preferiremos usar goals, sem itálico, que é a nomenclatura mais utilizada, exceto quando for conveniente utilizar ``busca'' ou ``objetivo''). Um goal é escrito como um fato e é o que se busca ``provar'' a partir do programa. Intuitivamente, pode-se pensar no programa lógico como um conjunto de axiomas e no goal como uma hipótese que se quer provar a partir desses axiomas. Assim, um
goal, relativo a algum programa, pode ter o status de sucesso, se ele pode ser provado a partir do programa, falha se não, ou, se foi um goal mal escrito, pode gerar um erro (isto é, o goal gera um erro quando não é ``compreensível'' a partir da gramática utilizada pelo interpretador). Mais especificamente, um goal é uma \textit{conjunção}\footnote{Isto é, uma sequência de proposições unidas por um \textit{e} lógico. Algo como $p_1$ e
  ... e $p_n$, onde os $p_i$ são proposições.}, escrita como \textit{$p_1,p_2,...,p_n.$}, onde cada vírgula pode ser lida como um \textit{e} lógico (assim, lê-se um goal como \textit{$p_1$ e $p_2$ e ... e
  $p_n.$}, onde $p_i$ é
entendida como uma proposição que pode ser verdadeira ou falsa\footnote{Na verdade, como veremos, uma interpretação mais próxima da realidade do programa lógico é uma baseada na lógica construtivista, mas, por enquanto, é suficiente pensar em um goal como uma conjunção no sentido clássico.}).

Dessa forma, goals, assim como regras são como cláusulas de Horn\footnote{Também, apesar de mais raramente, chamadas \textit{cláusulas de McKinsey}. Elas foram usadas primeiramente por Mckinsey, como notado por Horn \cite{horn}.} (isto é, cláusulas do tipo C se $A_1$ e ... e $A_n$). Como pode imaginar, o procedimento para a prova de uma cláusula de Horn é de alguma importância para programas lógicos.

Para diferenciarmos goals de fatos, goals serão, aqui, escritos como:
\[
  p?
\]

\noindent onde {\tt p?} indica a conjunção dos $p_i$, como explicado anteriormente, e pode ser entendida como a proposição\footnote{É algo como uma tradição usar ``funtor'' e ``proposição'' de forma quase que intercambiável, deixando a leitora potencialmente confusa quanto à diferença (se alguma) entre os dois. Este texto não tem a intenção de quebrar tradições (em particular, não essa), confiando que isso não lhe apresentará maior dificuldade no entendimento.} que se quer provar. Note que essa convenção será usada aqui mas não reflete como um goal pode parecer na natureza (em particular, no
Prolog padrão, assim como nas outras implementações conhecidas pelo autor, o ``\textit{?}'' é substituído pelo ``.'', tornando um goal diferenciável de um fato apenas pelo contexto).

Para melhor compreensão, considere o seguinte programa:\\

\lstinputlisting[caption=Árvore binária]{../Exemplos/Cap0/prog3_arvb.pl}

O goal {\tt $arvore\_b$(vazio)?} tem sucesso, já que é um dos fatos. O goal {\tt $arvore\_b$(arvore(raiz, vazio, vazio))?} também tem, já que {\tt $arvore\_b$(a, B, C)?} tem sucesso se $arvore\_b(A)$ e $arvore\_b(B)$ tiverem, o que ocorre. Perceba que, neste caso, o goal não tem sucesso segundo a primeira cláusula apenas e nem segundo a segunda. Ambas contribuem para a definição de $arvore\_b$.

Utilizamos a convenção de que termos capitalizados (isto é, com inicial maiúscula) denotam variáveis, enquanto os demais denotam constantes (a leitora descobrirá que, por notável coincidência, o Prolog faz uso da mesma convenção).

No geral, o que um programa lógico deveria fazer (isto é, o que a programadora tem em mente ao escrevê-lo) pode não ser a princípio claro. Numa tentativa de aliviar isso, usaremos aqui a convenção de usar nomes significativos, assumindo o significado usual (a não ser quando dito o contrário), para os elementos relevantes. Assim, por exemplo, o seguinte trecho:

\lstinputlisting[caption=Pai e filho]{../Exemplos/Cap0/prog4_pai.pl}
\label{lst:pai_filho}


Indica que Pai tem a relação \textit{pai/2} com Filho se Filho tem a relação \textit{filho} com Pai (em outras palavras, um Pai é pai de um Filho de Filho é filho de Pai). Mas não é assumido que o interpretador do programa tenha conhecimento sobre o que é \textit{pai} ou \textit{filho}, ou seja, essa interpretação é relevante para o leitor do programa apenas (o que também significa que o leitor do programa pode ler \textit{pai} e \textit{filho} de várias formas e um programa pode, assim,
ser interpretado de diversas maneiras).

Com essa discussão em mente, será ocasionalmente útil ter o \textit{significado} de um programa lógico definido de forma algo mais precisa:

  \theoremstyle{definition}
  \begin{definition} \textbf{Significado de um programa lógico} é o conjunto de goals deduzíveis a partir dele (isto é, os goals que obtêm sucesso se aplicados ao programa).
  \end{definition}

  Na verdade, essa é a definição procedural do significado de um programa lógico (apesar de que, como veremos posteriormente, essa distinção é imaterial) e, vale notar, ela é sempre bem definida (isto é, todo programa lógico tem um significado bem definido). Nesse contexto, o significado intencionado pela programadora (isto é, ``o que ela quer dizer com o programa'') é um conjunto de goals que pode ou não estar contido no significado do programa. Assim, podemos nos perguntar ``Será que o
  programa diz tudo que se quer que ele diga?'' (isto é, se o significado intencionado está contido no significado do programa), ou ``Será que tudo o que ele diz é correto?'' (isto é, se o significado do programa está contido no intencionado). No primeiro caso, se o significado intencionado estiver contido no do programa, dizemos que o programa é \textit{completo} e, no segundo, que ele é \textit{correto}.

  Por exemplo, digamos que o programa \ref{lst:pai_filho}  seja um trecho de um programa no qual a programadora deseja modelar as relações entre programas e especificações de software atuais e antigos, de forma que A é pai de B se A veio antes de B e B herda características de A, como partes do código ou especificações (como é possível ver, ela apenas começou a escrever o programa). Assim, estão no significado intencionado goals como {\tt pai(gnu, linux)?} e {\tt pai(dos, windows)?}, enquanto que o
  significado do programa é {\tt pai(d,c)?} (esse programa é correto? e completo?).


  \begin{thebibliography}{1}

    \bibitem{carnap}
     Carnap, Rudolf,
     Logische Syntax der Sprache,
     Wien (Viena): Julius Springer (1968)

     \bibitem{horn}
     Horn, Alfred,
     On Sentences Which are True of Direct Unions of Algebras,
     J. Symbolic Logic 16 (1951),
     no. 1,
     pp 14

  \end{thebibliography}

\end{document}
