\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[utf8]{inputenc}
\usepackage{placeins}

\usepackage{amsthm}

\theoremstyle{definition}
\newtheorem{definition}{Definição}[section]

\theoremstyle{remark}
\newtheorem*{remark}{Remark}


%
% TODO: revisar esta seção!
%


\begin{document}
\section{Modelo Computacional de Programas Lógicos}

Considere o seguinte programa:

resistor(power,nl).\\
resistor(power,n2).\\
transistor(n2,ground,nl).\\
transistor(n3,n4,n2).\\
transistor(n5,ground,n4).\\

inverter(Input, Output) :-\\
  transistor(input, ground, Output),\\
  resistor(power, Output).\\

$
nand\_gate(Input 1 ,Input2,Output) :-\\
  transistor(Inputl,X,Output),\\
  transistor(Input2,ground,X),\\
  resistor(power,Output).\\

and\_gate(Inputl,Input2,Output) :-\\
  nand\_gate(Inputl,Input2,X),\\
  inverter(X,Output).
$
\\
Qual será o resultado do goal \tt{$and_gate(In1, In2, Out)?$}, a leitora pode se perguntar. Mais do que isso, ela pode se perguntar ``Será que, dado um programa qualquer e um goal qualquer dá para \textit{calcular} o resultado do goal?''. Te convido a refletir por alguns momentos sobre essa questão.

%Note que, como o goal consiste contém variáveis (lembre-se que o que for capitalizado em programas lógicos denota uma variável), um resultado não é só \textit{sucesso} ou \textit{falha}, mas
%também, possivelmente, uma substituição para valores das variáveis (isto é, valores para as variáveis tal que o goal tenha sucesso).

A leitora pode imaginar que, se houvessem muitos programas com goals de resultados incalculáveis, programação lógica não seria tão útil, então esse não deve ser o caso. Mas mais do que isso, com algumas hipóteses (mais ou menos) razoáveis, temos o seguinte resultado (estabelecido por A. Robinson):

\newtheorem{Teorema da unificação}{
  Existe um algoritmo, chamado algoritmo de unificação, que checa se um goal é consistente com um programa lógico (isto é, se ele \textit{sucede} ou \textit{falha}) e, se for, calcula uma substituição para ele.
}

A leitora atenta vai notar que ainda não disse o que quero dizer com ``uma substituição'', mas isso vai ficar claro logo. Ela vai notar também que esse resultado não nos provê um método para resolver o nosso problema. Isso é resolvido pelo \textbf{algoritmo de Martelli-Montanari}:
\vspace{0.5cm}

\begin{itemize}
    \item (a) Escolha uma das proposições $p_i(t_1, ..., t_n)$ presentes no goal (lembre-se que um goal é entendido como uma conjunção de proposições);
    \item (b) Das proposições presentes no programa, escolha não-determinísticamente uma que tenha a forma de uma das abaixo e realize a ação especificada:
\end{enumerate}

\begin{enumerate}
    \item $f(k_1, ..., k_m) = p_i(t_1, ..., t_n)$, onde $m = n$, $f = p_i$: troque $t_l$ por $s_l$;
    \item $f(k_1, ..., k_m) = p_i(t_1, ..., t_n)$, onde $f \neq p_i$: delete essa equação e pare, retorne com falha;
    \item $x = x$: delete a equação;
    \item $x = y$, onde $x$ é uma variável, mas $y$ não: troque $x$ por $y$ em todas as proposições consideradas;
    \item $x = y$, onde $x$ é variável de $y$ (isto é, $y$ é algo como $y(a_1, ..., x, ..., a_n))$: pare e retorne com falha.
\end{enumerate}

\begin{itemize}
    \item Se existe mais algum $p_i$ a ser escolhido, volte ao item (a), se não retorne com sucesso.
\end{itemize}

Antes de estudarmos mais a fundo o funcionamento do algoritmo de Martelli-Montanari, precisamos saber o que é uma \textit{substituição}. Intuitivamente, ela é o que parece ser: a substituição de uma variável por um valor atômico ou, possívelmente, uma outra variável. Mais em geral, dada a cláusula \textbf{P}: \tt{p($A_1$, ..., $A_n$)}, uma substituição
\u{o} sobre P, denotada P\u{o}, é um conjunto (possívelmente vazio) de atribuição de valores às variáveis de $A_i$ de P. Uma atribuição é escrita como $A_i = B$, onde o símbolo ``='' deve ser entendido como usado em álgebra (isto é, como denotando uma relação simétrica de igualdade entre $A_i$ e $B$, não como geralmente usado em programação, como um operador de atribuição). Não pense em ``='' como um operador de atribuição, mas sim como algo que expressa a relação de dois termos terem o mesmo valor.

Até então, evitamos lidar com variáveis muito a fundo. Isso porque elas adicionam complicações importantes (na verdade, essenciais, como logo ficará patente). Mas voltando ao algoritmo de unificação...

Intuitivamente, ele tenta provar o goal a partir do programa de forma construtiva: tenta construir uma solução por meio de substituições e, se não chegar a uma contradição séria demais no processo (uma contradição que não pode ser corrigida. continue lendo), termina com sucesso, ``retornando'' (não no sentido de uma função que retorna um valor, mas no de mostrar ao usuário do programa) a substituição realizada (na verdade, extritamente falando, ele não precisa ``retornar'' as substituições,
mas assumiremos que retorna).

No item (a), escolhemos um dos termos do goal para provar. Isso porque, como discutido anteriormente, o goal é verdadeiro se cada um de seus termos o for: Provando todos os $p_i$, provamos o goal.

Em seguida, no item (b), escolhemos não-determínisticamente\footnote{No geral, podem existir várias escolhas possíveis e pode ser que por algumas sequências de escolhas de cláusulas podemos nunca chegar a uma prova do goal, apesar de ele ser deduzível a partir de outras cláusulas. Quando dizemos que a escolha é não-determinística, queremos dizer que, se existem conjuntos de escolhas que provem o goal, um desses conjuntos é escolhido (a escolha é feita entre as cláusulas que podem provar o
  goal). Na prática, isso pode ser implementado apenas aproximadamente, mas, aind assim, é uma abstração que pode levar a aplicações interessantes, em particular de, assim chamados, \textit{programas não-determinísticos}.} uma das cláusulas (digamos, a cláusula $m_j$) do programa para provar $p_i$. Essa operação pode ser vista como a tentativa de unificação de $p_i$ com $m_j$, e assim nos referiremos a ela.

Os itens de 1 a 5 são referentes a um passo da unificação.

Veja o seguinte exemplo.
Digamos que se tenha o seguinte programa P:






\end{document}
